<html>
  <head>
    <!-- https://getbootstrap.com/docs/4.0/getting-started/introduction/ -->
    <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/4.1.0/css/bootstrap.min.css">
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.14.0/umd/popper.min.js"></script>
    <script src="https://maxcdn.bootstrapcdn.com/bootstrap/4.1.0/js/bootstrap.min.js"></script>
  </head>
  <body>
    <div class='container'>
      <div class='row'>
      <fieldset>
        <legend>Axial Flux Generator Designer (mm)</legend>
        <form onchange="draw()">
          <div class="card-columns">
            <!-- type="text" pattern="[0-9]+" maxlength="3" minlength="1" -->
            <!-- type="number" min="1" max="9999" -->
            <div class='card  text-nowrap'>
              <div class=''>
                  <label for="num_magnets">Number of Magnets</label>
                  <input type="number" id="num_magnets" name="num_magnets" placeholder="# magnets"
                        min="4" max="9999" step='2' value="12" required />
              </div>
              <div class=''>
                <label for="mag_shape">Shape of Magnet</label>
                <input type = "radio"
                      name = "mag_shape"
                      id = "shapeRect"
                      value = "rect"
                      checked = "checked" />
                <label for = "shapeRect">rect</label>
                <input type = "radio"
                      name = "mag_shape"
                      id = "shapeCircle"
                      value = "circle" />
                <label for = "shapeCircle">circle</label>
              </div>
              <div id='dia_magnet_group' class=''>
                  <label for="dia_magnet">Dia of Magnet</label>
                  <input type="number" id="dia_magnet" name="dia_magnet" placeholder="Magnet Dia"
                        min="1" max="9999" value="20" required />
              </div>
              <div id='w_magnet_group' class=''>
                  <label for="w_magnet">Magnet Width</label>
                  <input type="number" id="w_magnet" name="w_magnet" placeholder="Magnet Width"
                        min="1" max="9999" value="20" required />
              </div>
              <div id='h_magnet_group' class=''>
                  <label for="h_magnet">Magnet Height</label>
                  <input type="number" id="h_magnet" name="h_magnet" placeholder="Magnet Height"
                        min="1" max="9999" value="15" required />
              </div>
            </div>
            <div class='card  text-nowrap'>
              <div class=''>
                  <label for="outside_dia">Outside Diameter</label>
                  <input type="number" id="outside_dia" name="outside_dia" placeholder="Outside Dia"
                        min="1" max="9999" value="150" required />
              </div>
              <div class=''>
                  <label for="in_dia">Inside Diameter</label>
                  <input type="number" id="in_dia" name="in_dia" placeholder="Inside Dia"
                        min="1" max="9999" value="30" required />
              </div>
            </div>
            <div class='card  text-nowrap'>
              <div class=''>
                <label for="coil_type">Type of Coil</label>
                <input type = "radio"
                      name = "coil_type"
                      id = "coilSerpentine"
                      value = "serpintine"
                      checked = "checked" />
                <label for = "coilSerpentine">serpentine</label>
                <input type = "radio"
                      name = "coil_type"
                      id = "coilLoops"
                      value = "loops"  />
                <label for = "coilLoops">loops</label>
              </div>
              <div class=''>
                  <label for="mag_out_dia">Coil Outside Diameter</label>
                  <input type="number" id="mag_out_dia" name="mag_out_dia" placeholder="Coil Outside Dia"
                        min="1" max="9999" value="120" required />
              </div>
              <div class=''>
                  <label for="mag_mid_dia">Mag Mid Diameter</label>
                  <input type="number" id="mag_mid_dia" name="mag_mid_dia" placeholder="Mag Mid Dia"
                        min="1" max="9999" value="90" required />
              </div>
              <div class=''>
                  <label for="mag_in_dia">Coil Inside Diameter</label>
                  <input type="number" id="mag_in_dia" name="mag_in_dia" placeholder="Coil Inside Diameter"
                        min="1" max="9999" value="60" required />
              </div>
            </div>
          </div>
        </form>
      </fieldset>
    </div>
    <div class='row'>
      <div id='errors' style="color:red"></div>
    </div>
    <div class='row'>
      <div class='col-sm bg-primary p-0 m-0'>
        <!-- <canvas id="turbine" width="200" height="200"></canvas> -->
        <div class='bg-secondary'>
          <svg id="svg" viewBox="-100 -100 100 100">
            <!--<rect width="100%" height="100%" fill="grey"/>-->
            <path id="svgdiscpath" d=""/>
            <path id="svgcoilpath" d=""/>
            <path id="svgwrappath" d=""/>
            <path id="svgmagpath" d=""/>
          </svg>
        </div>
      </div>
      <div class='col-sm'>
        <a id='download' class='btn btn-primary pointer btn-lg active' href="">Download .svg</a>
        <div>Legend:</div>
        <ul>
        <div style="color:red">wire winder tool</div>
        <div style="color:orange">wire</div>
        <div style="color:lightblue">magnets</div>
        <div style="color:grey">rotor/stator disc(s), resin mold</div>
        </ul>
      </div>
    </div>
    </div>
    <style>
      @media (min-width: 576px) {
        .card-columns { column-count: 2; }
      }
      @media (min-width: 768px) {
        .card-columns { column-count: 2; }
      }
      @media (min-width: 992px) {
        .card-columns { column-count: 3; }
      }
      @media (min-width: 1200px) {
        .card-columns { column-count: 4; }
      }
    </style>
    <script>
      function clear(c="grey") {
        //var c = document.getElementById("myCanvas");
        var ctx = turbine.getContext("2d");
        ctx.save();
        ctx.beginPath();
        ctx.rect(0, 0, turbine.width, turbine.height);
        ctx.strokeStyle = c;
        ctx.fillStyle = c;
        ctx.fill();
        ctx.restore();
      }
      function arc( c, x,y, radius, start, end, ccw=false ) {
        var ctx = turbine.getContext("2d");
        ctx.save();
        ctx.beginPath();
        ctx.arc(x, y, radius, start, end, ccw);
        ctx.strokeStyle=c;
        ctx.stroke();
        ctx.restore();
      }
      function circle( c, x,y, radius ) {
        var ctx = turbine.getContext("2d");
        ctx.save();
        ctx.beginPath();
        ctx.arc(x, y, radius, 0, 2*Math.PI, false);
        ctx.strokeStyle=c;
        ctx.stroke();
        ctx.restore();
      }
      function rect( c, x,y,w,h, a ) {
        var ctx = turbine.getContext("2d");
        ctx.save();
        ctx.strokeStyle = c;
        ctx.translate(x,y);
        ctx.rotate(a);
        ctx.strokeRect(-w*0.5,-h*0.5,w,h);
        ctx.restore();
      }
      function line( c, x, y, x2, y2 ) {
        var ctx = turbine.getContext("2d");
        ctx.save();
        ctx.strokeStyle=c;
        ctx.beginPath();
        ctx.moveTo( x, y );
        ctx.lineTo( x2, y2 );
        ctx.stroke();
        ctx.restore();
      }
      function radialToCartesian( x,y,radius,angle_rad ) {
        return {
          x: x + radius * Math.cos( angle_rad ),
          y: y + radius * Math.sin( angle_rad )
        };
      }
      function makePath( path ) {
        path[0] = "M" + path[0]; // warning, modifies array
        path[1] = "L" + path[1];
        path.push("Z");
        return path.join(' ');
      }
      function setPath( c, svgpath, path ) {
        svgpath.setAttribute('d',path);
        svgpath.setAttribute('stroke', c);
        svgpath.setAttribute('fill','none');
      }
      function clearPath( svgpath ) {
        svgpath.setAttribute('d','');
      }
      function arcPath( x, y, r, start, stop ) {
        let path = [];
        for (let s=start; s <= stop; s += 2*Math.PI/30) { // resolution of 30
          let xy = radialToCartesian( x,y,r,s );
          path.push(`${xy.x},${xy.y}`);
        }
        return makePath( path );
      }
      function circlePath( x, y, r ) {
        return arcPath( x, y, r, 0, 2*Math.PI )
      }
      function rotPoint(ox,oy,x,y,a) {
        return { x: ox + x*Math.cos(a) - y*Math.sin(a),   y: oy + x*Math.sin(a) + y*Math.cos(a) };
      }
      function rectPath( x,y,w,h, a ) {
        let path = [];
        let p0 = rotPoint( x,y,-w/2, -h/2, a );
        let p1 = rotPoint( x,y,+w/2, -h/2, a );
        let p2 = rotPoint( x,y,+w/2, +h/2, a );
        let p3 = rotPoint( x,y,-w/2, +h/2, a );
        path.push(`${p0.x},${p0.y}`);
        path.push(`${p1.x},${p1.y}`);
        path.push(`${p2.x},${p2.y}`);
        path.push(`${p3.x},${p3.y}`);
        return makePath(path);
      }
      function createSVGDownload(svg, ahref) {
        // first create a clone of our svg node so we don't mess the original one
        var clone = svg.cloneNode(true);
        // parse the styles
        //parseStyles(clone);

        // create a doctype
        var svgDocType = document.implementation.createDocumentType('svg', "-//W3C//DTD SVG 1.1//EN", "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd");
        // a fresh svg document
        var svgDoc = document.implementation.createDocument('http://www.w3.org/2000/svg', 'svg', svgDocType);
        // replace the documentElement with our clone 
        svgDoc.replaceChild(clone, svgDoc.documentElement);
        // get the data
        var svgData = (new XMLSerializer()).serializeToString(svgDoc);

        // now you've got your svg data, the following will depend on how you want to download it
        // e.g yo could make a Blob of it for FileSaver.js
        /*
        var blob = new Blob([svgData.replace(/></g, '>\n\r<')]);
        saveAs(blob, 'myAwesomeSVG.svg');
        */
        // here I'll just make a simple a with download attribute

        ahref.href = 'data:image/svg+xml; charset=utf8, ' + encodeURIComponent(svgData.replace(/></g, '>\n\r<'));
        ahref.download = 'file.svg';
        //ahref.innerHTML = 'download the svg file';
      };
      function sqr( n ) { return n*n; }
      function dist( p0, p1 ) {
        return Math.sqrt( sqr( p0.x - p1.x ) + sqr( p0.y - p1.y ) );
      }
      function draw() {
        errors.innerHTML = '';

        // update controls
        dia_magnet_group.hidden = !shapeCircle.checked;
        w_magnet_group.hidden = shapeCircle.checked;
        h_magnet_group.hidden = shapeCircle.checked;

        // construct the svg

        //clear();
        let c0 = "#aaaaaa";
        let c1 = "#99bbff";
        let c2 = "#ff9900";
        let c3 = "#ff0000";
        let vwidth = 0, vheight = 0;
        let pos = { x: 0, y: 0 };

        // disc geometry
        //arc( c0,pos.x,pos.y, outside_dia.value/2, 0, 2*Math.PI );
        //arc( c0,pos.x,pos.y, in_dia.value/2, 0, 2*Math.PI );
        setPath(c0, svgdiscpath,
            [circlePath( pos.x,pos.y, outside_dia.value/2 ),
            circlePath( pos.x,pos.y, in_dia.value/2 )].join(' ')
        );

        // wire geometry
        if (num_magnets.value % 2 == 1) errors.innerHTML = "ERROR: please give an even number of magnets";
        let arc_len_deg = 360/(num_magnets.value*0.5);
        let arc_len_rad = arc_len_deg * Math.PI/180;
        let start = 0;
        let end = 2*Math.PI - arc_len_rad*0.5;
        {
          let path = [];
          let coilWinderCircumference = 0;
          let winder_path = [];
          for (let x = start; x < end; x += arc_len_rad) {
            // generate some arc stats for this iteration
            let s = x;
            let s1d = arc_len_rad*0.5;
            let s1 = s+s1d;
            let s2d = arc_len_rad;
            let s2 = s+s2d;
            let inner_end_prev  = radialToCartesian( pos.x,pos.y, mag_in_dia.value/2, s );
            let outer_start     = radialToCartesian( pos.x,pos.y, mag_out_dia.value/2, s );
            let outer_end       = radialToCartesian( pos.x,pos.y, mag_out_dia.value/2, s1 );
            let inner_start     = radialToCartesian( pos.x,pos.y, mag_in_dia.value/2, s1 );
            let inner_end       = radialToCartesian( pos.x,pos.y, mag_in_dia.value/2, s2 );
            let outer_start_next= radialToCartesian( pos.x,pos.y, mag_out_dia.value/2, s2 );
            // one big loop of wire (minimize waste, easier to wind, etc.)
            if (coilSerpentine.checked) {
              //line( c2,outer_start.x, outer_start.y, outer_end.x, outer_end.y );
              //line( c2,inner_start.x, inner_start.y, inner_end.x, inner_end.y );
              //line( c2,inner_end_prev.x, inner_end_prev.y, outer_start.x, outer_start.y );
              //line( c2,outer_end.x, outer_end.y, inner_start.x, inner_start.y );
              path.push(`${inner_end_prev.x},${inner_end_prev.y}`);
              path.push(`${outer_start.x},${outer_start.y}`);
              path.push(`${outer_end.x},${outer_end.y}`);
              path.push(`${inner_start.x},${inner_start.y}`);
              path.push(`${inner_end.x},${inner_end.y}`);
              coilWinderCircumference += dist( inner_end_prev, outer_start );
              coilWinderCircumference += dist( outer_start, outer_end );
              coilWinderCircumference += dist( outer_end, inner_start );
              coilWinderCircumference += dist( inner_start, inner_end );
            } else {
              // individual loops
              let subpath = [];
              subpath.push(`${inner_end_prev.x},${inner_end_prev.y}`);
              subpath.push(`${outer_start.x},${outer_start.y}`);
              subpath.push(`${outer_end.x},${outer_end.y}`);
              subpath.push(`${inner_start.x},${inner_start.y}`);
              subpath.push(`${inner_end_prev.x},${inner_end_prev.y}`);
              path.push( makePath( subpath ) );
              subpath = [];
              subpath.push(`${outer_end.x},${outer_end.y}`);
              subpath.push(`${inner_start.x},${inner_start.y}`);
              subpath.push(`${inner_end.x},${inner_end.y}`);
              subpath.push(`${outer_start_next.x},${outer_start_next.y}`);
              subpath.push(`${outer_end.x},${outer_end.y}`);
              path.push( makePath( subpath ) );
              winder_path = subpath; // we can use this shape for our winder geometry...
            }
          }
          if (coilSerpentine.checked) {
            setPath( c2, svgcoilpath, makePath( path ) );

            // approx radius for the coil winder
            let coilWinderRadius = coilWinderCircumference / (2*Math.PI);

            // setup the svg's viewbox so it zooms in nice
            vwidth = vheight = Math.max( coilWinderRadius*2, outside_dia.value );

            // as much as we can, unwind the serpentine so we have a big (almost round) polygon,
            // so it will tend to crimp the wire in the right places to guide in bending the serpentine shape
            for (let x = start; x < end; x += arc_len_rad) {
              // generate some arc stats for this iteration
              let s = x;
              let s1d = arc_len_rad*0.5;
              let s1 = s+s1d;
              let s2d = arc_len_rad;
              let s2 = s+s2d;
              let inner_end_prev  = radialToCartesian( pos.x,pos.y, mag_in_dia.value/2, s );
              let outer_start     = radialToCartesian( pos.x,pos.y, mag_out_dia.value/2, s );
              let outer_end       = radialToCartesian( pos.x,pos.y, mag_out_dia.value/2, s1 );
              let inner_start     = radialToCartesian( pos.x,pos.y, mag_in_dia.value/2, s1 );
              let inner_end       = radialToCartesian( pos.x,pos.y, mag_in_dia.value/2, s2 );
              let outer_start_next= radialToCartesian( pos.x,pos.y, mag_out_dia.value/2, s2 );
              // we're going to project (move w/ no scale) 2 segments to the coilWinderRadius circle
              // the outer and the inner segments.  The segments inbetween will magically appear correct. :)
              // * get each segment's length
              let i1 = dist( outer_start, outer_end );
              let i3 = dist( inner_start, inner_end );
              // * coilWinderRadius circle is always larger than mag_out_dia
              //   if we pushed the segment out to the larger coilWinderRadius circle (same length)
              //   calc the (now narrower) sweep angle that sweeps the segment length
              let i1r_half = Math.asin(i1*0.5/coilWinderRadius); // sin(t) = o/a
              let i3r_half = Math.asin(i3*0.5/coilWinderRadius);
              // * calc the angle that passes through each segment's center point
              let s_s1 = s + s1d/2;
              let s1_s2 = s1 + s1d/2;
              // * calc the points for 3 segments, add to the path (4th segment we get for free next iteration)
              let p0 = radialToCartesian( pos.x,pos.y, coilWinderRadius, s_s1 - i1r_half );
              let p1 = radialToCartesian( pos.x,pos.y, coilWinderRadius, s_s1 + i1r_half );
              let p2 = radialToCartesian( pos.x,pos.y, coilWinderRadius, s1_s2 - i3r_half );
              let p3 = radialToCartesian( pos.x,pos.y, coilWinderRadius, s1_s2 + i3r_half );
              winder_path.push(`${p0.x},${p0.y}`);
              winder_path.push(`${p1.x},${p1.y}`);
              winder_path.push(`${p2.x},${p2.y}`);
              winder_path.push(`${p3.x},${p3.y}`);
            }
            setPath( c3, svgwrappath, makePath( winder_path ) );

            // lazy approach, just make the winder a pure circle
            // (inaccurate because the serpentine is chunky-polygonal, not smooth-curved,
            //  so your wire loop'll be _slightly_ too long this way)
            //setPath( c3, svgwrappath, circlePath( pos.x, pos.y, coilWinderRadius ) );
          } else {
            // setup the svg's viewbox so it zooms in nice
            vwidth = vheight = outside_dia.value;

            setPath( c2, svgcoilpath, path.join(' ') );
            //clearPath( svgcoilpath );
            setPath( c3, svgwrappath, winder_path );
            //clearPath( svgwrappath );
          }
        }

        // magnet geometry
        {
          let path = [];
          for (let x = start; x < end; x += arc_len_rad) {
            let s = x;
            let s1 = s+arc_len_rad*0.5;
            let s2 = s+arc_len_rad;
            let mag_centerN = radialToCartesian( pos.x,pos.y, mag_mid_dia.value/2, s );
            let mag_centerS = radialToCartesian( pos.x,pos.y, mag_mid_dia.value/2, s1 );
            if (shapeCircle.checked) {
              //circle( c1,mag_centerN.x, mag_centerN.y, dia_magnet.value*0.5 );
              //circle( c1,mag_centerS.x, mag_centerS.y, dia_magnet.value*0.5 );
              path.push( circlePath( mag_centerN.x, mag_centerN.y, dia_magnet.value*0.5 ) );
              path.push( circlePath( mag_centerS.x, mag_centerS.y, dia_magnet.value*0.5 ) );
            } else {
              //rect( c1,mag_centerN.x, mag_centerN.y, w_magnet.value, h_magnet.value, s );
              //rect( c1,mag_centerS.x, mag_centerS.y, w_magnet.value, h_magnet.value, s1 );
              path.push( rectPath( mag_centerN.x, mag_centerN.y, w_magnet.value, h_magnet.value, s ) );
              path.push( rectPath( mag_centerS.x, mag_centerS.y, w_magnet.value, h_magnet.value, s1 ) );
            }
            setPath( c1, svgmagpath, path.join(' ') );
          }
        }
        svg.setAttribute( 'viewBox', `${- +vwidth/2 - 2} ${- +vheight/2 - 2} ${+vwidth + 4} ${+vheight + 4}` );
        createSVGDownload( svg, download );
      }
      function init() {
        draw();
      }
      window.onload = init();
      //init();
    </script>

  </body>
</html>

