<html>
  <head>
    <!-- https://getbootstrap.com/docs/4.0/getting-started/introduction/ -->
    <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/4.1.0/css/bootstrap.min.css">
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.14.0/umd/popper.min.js"></script>
    <script src="https://maxcdn.bootstrapcdn.com/bootstrap/4.1.0/js/bootstrap.min.js"></script>
  </head>
  <body>
    <div class='container'>
      <div class='row'>
      <fieldset>
        <legend>Axial Flux Generator Designer (mm)</legend>
        <form onchange="draw()">
          <div class="card-columns">
            <!-- type="text" pattern="[0-9]+" maxlength="3" minlength="1" -->
            <!-- type="number" min="1" max="9999" -->
            <div class='card  text-nowrap'>
              <div class=''>
                  <label for="num_magnets">Number of Magnets</label>
                  <input type="number" id="num_magnets" name="num_magnets" placeholder="# magnets"
                        min="4" max="9999" step='1' value="12" required />
              </div>
              <div class=''>
                <label for="mag_shape">Shape of Magnet</label>
                <input type = "radio"
                      name = "mag_shape"
                      id = "shapeRect"
                      value = "rect"
                      checked = "checked" />
                <label for = "shapeRect">rect</label>
                <input type = "radio"
                      name = "mag_shape"
                      id = "shapeCircle"
                      value = "circle" />
                <label for = "shapeCircle">circle</label>
              </div>
              <div id='dia_magnet_group' class=''>
                  <label for="dia_magnet">Dia of Magnet</label>
                  <input type="number" id="dia_magnet" name="dia_magnet" placeholder="Magnet Dia"
                        min="1" max="9999" value="20" required />
              </div>
              <div id='w_magnet_group' class=''>
                  <label for="w_magnet">Magnet Width</label>
                  <input type="number" id="w_magnet" name="w_magnet" placeholder="Magnet Width"
                        min="1" max="9999" value="20" required />
              </div>
              <div id='h_magnet_group' class=''>
                  <label for="h_magnet">Magnet Height</label>
                  <input type="number" id="h_magnet" name="h_magnet" placeholder="Magnet Height"
                        min="1" max="9999" value="15" required />
              </div>
              <div class=''>
                  <label for="mag_mid_dia">Magnet Placement Diameter</label>
                  <input type="number" id="mag_mid_dia" name="mag_mid_dia" placeholder="Mag Mid Dia"
                        min="1" max="9999" value="90" required />
              </div>
            </div>
            <div class='card  text-nowrap'>
              <div class=''>
                  <label for="outside_dia">Outside Diameter</label>
                  <input type="number" id="outside_dia" name="outside_dia" placeholder="Outside Dia"
                        min="1" max="9999" value="130" required />
              </div>
              <div class=''>
                  <label for="in_dia">Inside Diameter</label>
                  <input type="number" id="in_dia" name="in_dia" placeholder="Inside Dia"
                        min="1" max="9999" value="30" required />
              </div>
            </div>
            <div class='card  text-nowrap'>
              <div class=''>
                <label for="coil_type">Type of Coil</label>
                <input type = "radio"
                      name = "coil_type"
                      id = "coilSerpentine"
                      value = "serpintine"
                      checked = "checked" />
                <label for = "coilSerpentine">serpentine</label>
                <input type = "radio"
                      name = "coil_type"
                      id = "coilLoops"
                      value = "loops"  />
                <label for = "coilLoops">loops</label>
              </div>
              <div class=''>
                  <label for="mag_out_dia">Coil Outside Diameter</label>
                  <input type="number" id="mag_out_dia" name="mag_out_dia" placeholder="Coil Outside Dia"
                        min="1" max="9999" value="120" required />
              </div>
              <div class=''>
                  <label for="mag_in_dia">Coil Inside Diameter</label>
                  <input type="number" id="mag_in_dia" name="mag_in_dia" placeholder="Coil Inside Diameter"
                        min="1" max="9999" value="60" required />
              </div>
              <div class=''>
                  <label for="coil_thickness">Coil Thickness (dia)</label>
                  <input type="number" id="coil_thickness" name="coil_thickness" placeholder="Coil Thickness"
                        min="1" max="9999" value="1" required />
              </div>
            </div>
          </div>
        </form>
      </fieldset>
    </div>
    <div class='row'>
      <div id='errors' style="color:red"></div>
    </div>
    <div class='row'>
      <div class='col-sm bg-primary p-0 m-0'>
        <div style='background-color: #333333;'>
          <svg id="svg" viewBox="-100 -100 100 100">
            <!--<rect width="100%" height="100%" fill="grey"/>-->
            <path id="svgdiscpath" d=""/>
            <path id="svgcoilpath" d=""/>
            <path id="svgwrappath" d=""/>
            <path class='rot' id="svgmagpath" d=""/>
            <path class='rot' id="svgmagpath2" d=""/>
          </svg>
        </div>
      </div>
      <div class='col-sm'>
        <a id='download' class='btn btn-primary pointer btn-lg active' href="">Download .svg</a>
        <div>Legend:</div>
        <ul>
        <div style="color:#ff00aa">wire winder tool</div>
        <div style="color:#ff9900">wire</div>
        <div style="color:#99bbff">magnets</div>
        <div style="color:#aaaaaa">rotor/stator disc(s), resin mold</div>
        </ul>
      </div>
    </div>
    </div>
    <style>
      @media (min-width: 576px) {
        .card-columns { column-count: 2; }
      }
      @media (min-width: 768px) {
        .card-columns { column-count: 2; }
      }
      @media (min-width: 992px) {
        .card-columns { column-count: 3; }
      }
      @media (min-width: 1200px) {
        .card-columns { column-count: 4; }
      }
      .rot {
        animation: rot 30.0s linear infinite;
      }
      @keyframes rot {
        0% {
          -webkit-transform:  rotate(180deg) rotate(0deg);
          -moz-transform:  rotate(180deg) rotate(0deg);
          transform: rotate(180deg) rotate(0deg);
        }
        100% {
          -webkit-transform:  rotate(180deg) rotate(360deg);
          -moz-transform:  rotate(180deg) rotate(360deg);
          transform: rotate(180deg) rotate(360deg);
        }
      }
    </style>
    <script>
      let c0 = "#aaaaaa";
      let c1 = "#99bbff";
      let c1b = "#99bb00";
      let c2 = "#ff9900";
      let c3 = "#ff00aa";


      //////////////////////////////////////
      // SVG generators
      //////////////////////////////////////

      // generate the 'd' attribute for a <path> from an array of points in `${x},${y}` (or 'x,y' or "x,y") string format.
      function makePath( path ) {
        path[0] = "M" + path[0]; // warning, modifies array
        path[1] = "L" + path[1];
        path.push("Z");
        return path.join(' ');
      }
      // setup the <svg><path> from a given color [c] and 'd' attribute [path].  (see makePath, circlePath, arcPath, rectPath)
      function setPath( c, svgpath, path, strokewidth=0.2 ) {
        svgpath.setAttribute('d',path);
        svgpath.setAttribute('stroke', c);
        svgpath.setAttribute('stroke-width', strokewidth);
        svgpath.setAttribute('fill','none');
      }
      function clearPath( svgpath ) {
        svgpath.setAttribute('d','');
      }
      // generate the 'd' attribute for a <svg><path> in the shape of an arc.  Use (0, 2*Math.PI) for circle.
      function arcPath( x, y, r, start, stop ) {
        let path = [];
        for (let s=start; s <= stop; s += 2*Math.PI/30) { // resolution of 30
          let xy = radialToCartesian( x,y,r,s );
          path.push(`${xy.x},${xy.y}`);
        }
        return makePath( path );
      }
      // generate the 'd' attribute for a <svg><path> in the shape of a circle.
      function circlePath( x, y, radius ) {
        return arcPath( x, y, radius, 0, 2*Math.PI )
      }
      // rotate a point x,y by a (rad), then offset by ox,oy
      function rotPoint(ox,oy,x,y,a) {
        return { x: ox + x*Math.cos(a) - y*Math.sin(a),   y: oy + x*Math.sin(a) + y*Math.cos(a) };
      }
      // generate the 'd' attribute for a <svg><path> in the shaped of a rectangle.
      // use a (rad) to rotate the rectangle.  x,y is the center point.  w,h is the size.
      function rectPath( x,y,w,h, a ) {
        let path = [];
        let p0 = rotPoint( x,y,-w/2, -h/2, a );
        let p1 = rotPoint( x,y,+w/2, -h/2, a );
        let p2 = rotPoint( x,y,+w/2, +h/2, a );
        let p3 = rotPoint( x,y,-w/2, +h/2, a );
        path.push(`${p0.x},${p0.y}`);
        path.push(`${p1.x},${p1.y}`);
        path.push(`${p2.x},${p2.y}`);
        path.push(`${p3.x},${p3.y}`);
        return makePath(path);
      }
      function createSVGDownload(svg, ahref) {
        // first create a clone of our svg node so we don't mess the original one
        var clone = svg.cloneNode(true);
        // parse the styles
        //parseStyles(clone);

        // create a doctype
        var svgDocType = document.implementation.createDocumentType('svg', "-//W3C//DTD SVG 1.1//EN", "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd");
        // a fresh svg document
        var svgDoc = document.implementation.createDocument('http://www.w3.org/2000/svg', 'svg', svgDocType);
        // replace the documentElement with our clone 
        svgDoc.replaceChild(clone, svgDoc.documentElement);
        // get the data
        var svgData = (new XMLSerializer()).serializeToString(svgDoc);

        // now you've got your svg data, the following will depend on how you want to download it
        // e.g yo could make a Blob of it for FileSaver.js
        /*
        var blob = new Blob([svgData.replace(/></g, '>\n\r<')]);
        saveAs(blob, 'myAwesomeSVG.svg');
        */
        // here I'll just make a simple a with download attribute

        ahref.href = 'data:image/svg+xml; charset=utf8, ' + encodeURIComponent(svgData.replace(/></g, '>\n\r<'));
        ahref.download = 'file.svg';
        //ahref.innerHTML = 'download the svg file';
      };

      //////////////////////////////////////
      // math and vector math  {x: 0, y: 0}
      //////////////////////////////////////

      // given an x,y offset, a radius and an angle (rad)
      // return the computed x,y point
      function radialToCartesian( x,y,radius,angle_rad ) {
        return {
          x: x + radius * Math.cos( angle_rad ),
          y: y + radius * Math.sin( angle_rad )
        };
      }
      // create a vector from a scalar (number)
      function vec( n, n2=n ) { return {x: n, y: n2}; }
      // square the number
      function sqr( n ) { return n*n; }
      // return the magnitude of the vector
      function mag( v ) {
        return Math.sqrt( sqr( v.x ) + sqr( v.y ) );
      }
      // reverse (invert) the direction of the vector
      function inv( v ) {
        return {x: -v.x, y: -v.y};
      }
      // return the distance from p0 to p1
      function dist( p0, p1 ) {
        return mag( sub( p0, p1 ) );
      }
      // return the unnormalized vector from p1 to p0
      function sub( p0, p1 ) {
        return {x: p0.x - p1.x, y: p0.y - p1.y};
      }
      // add p1 to p0
      function add( p0, p1 ) {
        return {x: p0.x + p1.x, y: p0.y + p1.y};
      }
      // multiply p1 & p0
      function mul( p0, p1 ) {
        return {x: p0.x * p1.x, y: p0.y * p1.y};
      }
      // normalize the vector
      function norm( v ) {
        let d = mag( v );
        return {x: v.x/d, y: v.y/d};
      }
      // return the normalized direction vector for the two points.
      function dir( p0, p1 ) {
        return norm( sub( p0, p1 ) );
      }

      // draw the diagram into the <svg>
      function draw() {
        errors.innerHTML = '';

        // update controls
        dia_magnet_group.hidden = !shapeCircle.checked;
        w_magnet_group.hidden = shapeCircle.checked;
        h_magnet_group.hidden = shapeCircle.checked;

        // construct the svg

        //clear();
        let vwidth = 0, vheight = 0;
        let pos = { x: 0, y: 0 };

        // disc geometry
        //arc( c0,pos.x,pos.y, outside_dia.value/2, 0, 2*Math.PI );
        //arc( c0,pos.x,pos.y, in_dia.value/2, 0, 2*Math.PI );
        setPath(c0, svgdiscpath,
            [circlePath( pos.x,pos.y, outside_dia.value/2 ),
            circlePath( pos.x,pos.y, in_dia.value/2 )].join(' ')
        );

        // wire geometry
        if (coilSerpentine.checked && +num_magnets.value % 2 == 1) errors.innerHTML = "ERROR: for serpentine coils, please give an even number of magnets";
        if (coilLoops.checked && +num_magnets.value % 2 == 1) errors.innerHTML = "ERROR: for loop coils, please give an even number of magnets";
        {
          let path = [];
          let coilWinderCircumference = 0;
          let winder_path = [];

          // one big loop of wire (minimize waste, easier to wind, etc.)
          if (coilSerpentine.checked) {
            let arc_len_deg = 360/(num_magnets.value*0.5);
            let arc_len_rad = arc_len_deg * Math.PI/180;
            // generate some arc stats for this iteration
            for (let x = 0; x < (+num_magnets.value/2); ++x) {
              let s = x * arc_len_rad;
              let s1d = arc_len_rad*0.5;
              let s1 = s+s1d;
              let s2d = arc_len_rad;
              let s2 = s+s2d;
              let inner_end_prev  = radialToCartesian( pos.x,pos.y, mag_in_dia.value/2, s );
              let outer_start     = radialToCartesian( pos.x,pos.y, mag_out_dia.value/2, s );
              let outer_end       = radialToCartesian( pos.x,pos.y, mag_out_dia.value/2, s1 );
              let inner_start     = radialToCartesian( pos.x,pos.y, mag_in_dia.value/2, s1 );
              let inner_end       = radialToCartesian( pos.x,pos.y, mag_in_dia.value/2, s2 );
              let outer_start_next= radialToCartesian( pos.x,pos.y, mag_out_dia.value/2, s2 );
              //line( c2,outer_start.x, outer_start.y, outer_end.x, outer_end.y );
              //line( c2,inner_start.x, inner_start.y, inner_end.x, inner_end.y );
              //line( c2,inner_end_prev.x, inner_end_prev.y, outer_start.x, outer_start.y );
              //line( c2,outer_end.x, outer_end.y, inner_start.x, inner_start.y );
              path.push(`${inner_end_prev.x},${inner_end_prev.y}`);
              path.push(`${outer_start.x},${outer_start.y}`);
              path.push(`${outer_end.x},${outer_end.y}`);
              path.push(`${inner_start.x},${inner_start.y}`);
              path.push(`${inner_end.x},${inner_end.y}`);
              coilWinderCircumference += dist( inner_end_prev, outer_start );
              coilWinderCircumference += dist( outer_start, outer_end );
              coilWinderCircumference += dist( outer_end, inner_start );
              coilWinderCircumference += dist( inner_start, inner_end );
            }

            setPath( c2, svgcoilpath, makePath( path ) );

            // approx radius for the coil winder
            let coilWinderRadius = coilWinderCircumference / (2*Math.PI);

            // setup the svg's viewbox so it zooms in nice
            vwidth = vheight = Math.max( coilWinderRadius*2, outside_dia.value );

            // as much as we can, unwind the serpentine so we have a big (almost round) polygon,
            // so it will tend to crimp the wire in the right places to guide in bending the serpentine shape
            for (let x = 0; x < (+num_magnets.value/2 - 0.5); ++x) {
              // generate some arc stats for this iteration
              let s = x * arc_len_rad;
              let s1d = arc_len_rad*0.5;
              let s1 = s+s1d;
              let s2d = arc_len_rad;
              let s2 = s+s2d;
              let inner_end_prev  = radialToCartesian( pos.x,pos.y, mag_in_dia.value/2, s );
              let outer_start     = radialToCartesian( pos.x,pos.y, mag_out_dia.value/2, s );
              let outer_end       = radialToCartesian( pos.x,pos.y, mag_out_dia.value/2, s1 );
              let inner_start     = radialToCartesian( pos.x,pos.y, mag_in_dia.value/2, s1 );
              let inner_end       = radialToCartesian( pos.x,pos.y, mag_in_dia.value/2, s2 );
              let outer_start_next= radialToCartesian( pos.x,pos.y, mag_out_dia.value/2, s2 );
              // we're going to project (move w/ no scale) 2 segments to the coilWinderRadius circle
              // the outer and the inner segments.  The segments inbetween will magically appear correct. :)
              // * get each segment's length
              let i1 = dist( outer_start, outer_end );
              let i3 = dist( inner_start, inner_end );
              // * coilWinderRadius circle is always larger than mag_out_dia
              //   if we pushed the segment out to the larger coilWinderRadius circle (same length)
              //   calc the (now narrower) sweep angle that sweeps the segment length
              let i1r_half = Math.asin(i1*0.5/coilWinderRadius); // sin(t) = o/a
              let i3r_half = Math.asin(i3*0.5/coilWinderRadius);
              // * calc the angle that passes through each segment's center point
              let s_s1 = s + s1d/2;
              let s1_s2 = s1 + s1d/2;
              // * calc the points for 3 segments, add to the path (4th segment we get for free next iteration)
              let p0 = radialToCartesian( pos.x,pos.y, coilWinderRadius, s_s1 - i1r_half );
              let p1 = radialToCartesian( pos.x,pos.y, coilWinderRadius, s_s1 + i1r_half );
              let p2 = radialToCartesian( pos.x,pos.y, coilWinderRadius, s1_s2 - i3r_half );
              let p3 = radialToCartesian( pos.x,pos.y, coilWinderRadius, s1_s2 + i3r_half );
              winder_path.push(`${p0.x},${p0.y}`);
              winder_path.push(`${p1.x},${p1.y}`);
              winder_path.push(`${p2.x},${p2.y}`);
              winder_path.push(`${p3.x},${p3.y}`);
            }
            setPath( c3, svgwrappath, makePath( winder_path ) );

            // lazy approach, just make the winder a pure circle
            // (inaccurate because the serpentine is chunky-polygonal, not smooth-curved,
            //  so your wire loop'll be _slightly_ too long this way)
            //setPath( c3, svgwrappath, circlePath( pos.x, pos.y, coilWinderRadius ) );
          } else {
            let arc_len_deg = 360/num_magnets.value;
            let arc_len_rad = arc_len_deg * Math.PI/180;
            // individual loops
            for (let x = 0; x < (+num_magnets.value); ++x) {
              // generate some arc stats for this iteration
              let s = x * arc_len_rad;
              let s1d = arc_len_rad;
              let s1 = s+s1d;
              // 1 2
              // 0 3
              let inner_end_prev  = radialToCartesian( pos.x,pos.y, mag_in_dia.value/2, s );
              let outer_start     = radialToCartesian( pos.x,pos.y, mag_out_dia.value/2, s );
              let outer_end       = radialToCartesian( pos.x,pos.y, mag_out_dia.value/2, s1 );
              let inner_start     = radialToCartesian( pos.x,pos.y, mag_in_dia.value/2, s1 );

              let coilt = +coil_thickness.value;
              let up1 = mul( dir( outer_start, inner_end_prev ), vec( coilt ) );
              let up2 = mul( dir( outer_end, inner_start ), vec( coilt ) );
              let dn1 = inv( up1 );
              let dn2 = inv( up2 );
              let lt = mul( dir( outer_start, outer_end ), vec( coilt ) );
              let rt = mul( dir( outer_end, outer_start ), vec( coilt ) );

              function coilshape( ox, oy ) {
                let subpath = [];
                {
                  let p0 = add( inner_end_prev, vec(ox,oy) );
                  let p1 = add( outer_start,    vec(ox,oy) );
                  let p2 = add( outer_end,      vec(ox,oy) );
                  let p3 = add( inner_start,    vec(ox,oy) );
                  subpath.push(`${p0.x},${p0.y}`);
                  subpath.push(`${p1.x},${p1.y}`);
                  subpath.push(`${p2.x},${p2.y}`);
                  subpath.push(`${p3.x},${p3.y}`);
                  subpath.push(`${p0.x},${p0.y}`);
                }

                let subpath2 = [];
                {
                  let p0 = add( add( add( inner_end_prev, rt ), up1 ), vec(ox,oy) );
                  let p1 = add( add( add( outer_start, dn1 ),    rt ), vec(ox,oy) );
                  let p2 = add( add( add( outer_end, dn2 ),      lt ), vec(ox,oy) );
                  let p3 = add( add( add( inner_start, up2 ),    lt ), vec(ox,oy) );
                  subpath2.push(`${p0.x},${p0.y}`);
                  subpath2.push(`${p1.x},${p1.y}`);
                  subpath2.push(`${p2.x},${p2.y}`);
                  subpath2.push(`${p3.x},${p3.y}`);
                  subpath2.push(`${p0.x},${p0.y}`);
                }

                return { subpath: makePath( subpath ), subpath2: makePath( subpath2 ) };
              }
              let shape = coilshape( 0,0 );
              path.push( shape.subpath );
              path.push( shape.subpath2 );

              // we can use this shape for our winder geometry...  it'll just be the last one we draw...  lazy, me. this was easy.
              let winder = coilshape( -4,4 );
              winder_path = [];
              winder_path.push( winder.subpath );
              winder_path.push( winder.subpath2 );
            }

            // setup the svg's viewbox so it zooms in nice
            vwidth = vheight = outside_dia.value;

            setPath( c2, svgcoilpath, path.join(' ') );
            //clearPath( svgcoilpath );
            setPath( c3, svgwrappath, winder_path.join(' ') );
            //clearPath( svgwrappath );
          }
        }

        // magnet geometry
        {
          let path1 = [];
          let path2 = [];
          for (let x = 0; x < +num_magnets.value; ++x) {
            let path;
            let arc_len_deg = 360/(num_magnets.value*0.5);
            let arc_len_rad = arc_len_deg * Math.PI/180;
            let s = x * arc_len_rad*0.5;
            let mag_centerN = radialToCartesian( pos.x,pos.y, mag_mid_dia.value/2, s );
            if (shapeCircle.checked) {
              //circle( c1,mag_centerN.x, mag_centerN.y, dia_magnet.value*0.5 );
              path = circlePath( mag_centerN.x, mag_centerN.y, dia_magnet.value*0.5 );
            } else {
              //rect( c1,mag_centerN.x, mag_centerN.y, w_magnet.value, h_magnet.value, s );
              path = rectPath( mag_centerN.x, mag_centerN.y, w_magnet.value, h_magnet.value, s );
            }
            if (x % 2 === 1)
              path1.push( path );
            else
              path2.push( path );
          }
          setPath( c1, svgmagpath, path1.join(' ') );
          setPath( c1b, svgmagpath2, path2.join(' ') );
        }
        svg.setAttribute( 'viewBox', `${- +vwidth/2 - 2} ${- +vheight/2 - 2} ${+vwidth + 4} ${+vheight + 4}` );
        createSVGDownload( svg, download );
      }
      function init() {
        draw();
      }
      window.onload = init();
      //init();
    </script>

  </body>
</html>

